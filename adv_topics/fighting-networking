- **Title** : Networking
- **Topics** :
  - Recap from Farnan&#39;s class
    - Choices: **UDP** vs. TCP
      - Why UDP?
        - Industry standard for fast-paced multiplayer games (fps, etc), use the UDP protocol to sync player movement and update game state.
        - **Challenges** : no guarantees of packet delivery like TCP, if we&#39;re not connected through Ethernet we could see a higher rate of packet loss
    - Choices: P2P vs. **Authoritative Server**
      - What are they?
        - Peer 2 Peer - direct connection
        - Authoritative Server - &quot;real game&quot; is being played on the server
          - **Client controls:** input actions, sending server actions, rendering to screen
          - **Server controls** : game state, sending client updates on how the game state is going
          - **Example FPS:** The client tells the server in which direction you fired a shot, and the server then figures out if that shot hit something.
      - Why fully authoritative server?
        - Industry standard
        - P2P has high potential for cheating (doesn&#39;t follow the &quot;never trust the client&quot; motto)
        - Authoritative version is clear
  - Rust Networking, has a very bare bones library for networking
    - **Net** : [https://doc.rust-lang.org/std/net/index.html](https://doc.rust-lang.org/std/net/index.html)
      - **std::net::SocketAddr** // represents socket addresses of either IPv4 or IPv6
      - **std::net::UdpSocket** // provides functionality for communication over UDP
        - **bind** // creates UDPSocket from a given address
        - **connect** // connects UDP socket to a remote address
        - **send** // sends data on the socket to the remote address (to which it is connected)
        - **sent\_to** // sends data on the socket to the given address
        - **recv** // receives a single datagram message on the socket from the remote address (to which it is connected)
        - **recv\_from** // receives a single datagram message on the socket
    - **Libc:** [https://docs.rs/libc/0.2.98/libc/](https://docs.rs/libc/0.2.98/libc/)
      - **Blocking vs Non Blocking** // what each does/ why it&#39;s required
        - **Polling**
    - **Basic server pseudocode:**
      - Bind to an IP address (it&#39;s own IP!)
      - Create a listening loop
        - a. Create a buffer
        - b. Receive information
    - **Basic client pseudocode:**
      - Bind to an IP address (it&#39;s own IP!)
      - Connect to a server&#39;s IP
      - Send information
    - **Buuuuut it gets more complicated, because:**
      - Passing datagrams is interesting, but not all that useful -\&gt; we needed to be able to pass objects
      - Dealing with different types of information being passed
      - Determining: What do we actually need to be sending for the game? When do we need to be sending information?
        - **Example** : In an action game, player&#39;s movements will probably be sent to the server many times per second, while your player&#39;s inventory status only needs to be sent when it changes
      - Servers sometimes need to send information to clients
      - Clients sometimes need to receive information from servers
      - Delays in networking that make it impossible to as fast as client-side input
  - **Basics approach: Iterative process**
    - A lot of different problems that needed to be solved, so we approached very systematically and intentionally
    - Slide with all of some of the highlights of the things we completed:
      - Creating chat apps (to server, group chat, duplex)
      - Passing objects over networking
      - Getting IP addresses from client
      - Setting up player number on server, sending to clients A and B
      - Using Farnan&#39;s example 8 and moving rectangles across network
      - Passing character state into game
  - **Serialization for objects**
    - Dealing with object translation
    - bincode::{serialize, deserialize};
      - serialize() // translate into Vec
      - deserialize() // translate Vec to CharacterState
        - deserialize::\&lt;CharacterState\&gt;(&amp;buffer)
    - serde\_derive::{Serialize, Deserialize};
      - #[derive(Serialize, Deserialize)]
  - **Threads for multiple, concurrent needs**
    - [https://doc.rust-lang.org/std/thread/](https://doc.rust-lang.org/std/thread/)
    - When you want concurrency, doing 2x things at once (example: if you are listening and sending input)
    - Example:

thread::spawn(move || loop { // standard thread stuff

send(&amp;socket\_clone);

});

  - **Client-Side Prediction**
    - **Challenge** : desyncs, so we know client side is faster than over network, we want to conceal the latency to the user (and make the game feel more seamless than it actually is)
    - **Solve** :
      - **Philosophy** : The client&#39;s actions are in the future, server is always in the past validating events
      - **Basics** : Client locally react to user input before the server has acknowledged the input and updated the game state, the server then validates input
      - **Techniques** :
        - **Delay-based**
          - Simple, common
          - Uses lockstep networking
          - Artificially delay the local player&#39;s inputs by the same amount of time. Then, in theory, both inputs will &quot;arrive&quot; at the same time, and can be executed on the same frame as expected.
        - **Rollback netcode**
          - **Solve for incorrect** : Interpolation/correct over a short time
    - **Port Forwarding**
      - Overview of what it is/why it&#39;s necessary
      - How it&#39;s done
- **Resources**
  - https://ki.infil.net/w02-netcode.html
  - https://ruoyusun.com/2019/03/28/game-networking-1.html
  - https://www.gabrielgambetta.com/client-server-game-architecture.html
  - https://www.pcgamer.com/netcode-explained/
  - https://heroiclabs.com/docs/expert-tcp-udp/
  - https://developer.valvesoftware.com/wiki/Source\_Multiplayer\_Networking
  - Computer Networks: A Systems Approach
